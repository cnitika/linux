
ğŸ” Investigating Ctrl+C and Ctrl+Z in Linux: What Really Happens?

In a Linux terminal, when you press Ctrl+C or Ctrl+Z during a running process, you're sending signals to control the process. Here's how it works:

ğŸŸ¥ Ctrl+C â€” Interrupt Signal (SIGINT)
-------------------------------------
- Signal sent: SIGINT (Signal Interrupt)
- Signal number: 2
- What it does: Immediately stops (terminates) the foreground process.
- Equivalent command:
  kill -2 <PID>

Example:
1. Run a long process (like sleep):
   sleep 100
2. Press Ctrl+C in the terminal.
3. This sends SIGINT to the process and terminates it.

ğŸŸ¨ Ctrl+Z â€” Terminal Stop Signal (SIGTSTP)
------------------------------------------
- Signal sent: SIGTSTP (Terminal Stop)
- Signal number: 20
- What it does: Suspends (pauses) the process and pushes it to the background.
- Equivalent command:
  kill -20 <PID>

Example:
1. Run a command:
   cat
2. Press Ctrl+Z in the terminal.
3. The process is paused and can be resumed with:
   fg    (brings it back to foreground)
   bg    (continues it in the background)

ğŸ› ï¸ Useful Commands for Process Control:
---------------------------------------
- fg       â†’ Resume suspended job in foreground
- bg       â†’ Resume suspended job in background
- jobs     â†’ List suspended/background jobs
- kill     â†’ Send custom signals to processes

ğŸ“Œ Bonus: Trap These Signals in Bash
You can even trap these signals to see custom messages:

trap "echo Interrupted!" SIGINT
trap "echo Stopped!" SIGTSTP

Run a loop:
while true; do sleep 1; done

Then press Ctrl+C or Ctrl+Z to see the message.

ğŸ¯ Conclusion:
Ctrl+C and Ctrl+Z are more than just shortcutsâ€”they're system signals controlling process behavior. Behind the scenes, itâ€™s just clean signal handling using `kill -2` and `kill -20`.
